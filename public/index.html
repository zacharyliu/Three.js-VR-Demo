<!doctype html>
<html lang="en">
<head>
    <title>Camera Texture (Three.js)</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style type="text/css">
        body
        {
            background: black;
            margin: 0px;
            overflow: hidden;
        }
    </style>
</head>
<body>

<script src="/js/three/three.67.js"></script>
<script src="/js/three/Detector.js"></script>
<script src="/js/three/Stats.js"></script>
<script src="/js/three/OrbitControls.js"></script>
<script src="/js/three/TrackballControls.js"></script>
<script src="/js/three/THREEx.KeyboardState.js"></script>
<script src="/js/three/THREEx.FullScreen.js"></script>
<script src="/js/three/THREEx.WindowResize.js"></script>
<script src="/threex.minecraft/threex.minecraft.js"></script>
<script src="/threex.minecraft/threex.minecraftcontrols.js"></script>
<script src="/threex.minecraft/threex.animation.js"></script>
<script src="/threex.minecraft/threex.animations.js"></script>
<script src="/threex.minecraft/threex.minecraftcharheadanim.js"></script>
<script src="/threex.minecraft/threex.minecraftcharbodyanim.js"></script>
<script src="/threex.minecraft/threex.minecraftplayer.js"></script>
<script src="/js/three/loaders/MTLLoader.js"></script>
<script src="/js/three/loaders/OBJMTLLoader.js"></script>
<script src="/js/physijs/physi.js"></script>


<!-- ------------------------------------------------------------ -->

<div id="ThreeJS" style="position: absolute; left:0px; top:0px"></div>
<script>
Physijs.scripts.worker = "/js/physijs/physijs_worker.js";
Physijs.scripts.ammo = "/js/physijs/examples/js/ammo.js";

/*
 Three.js "tutorials by example"
 Author: Lee Stemkoski
 Date: July 2013 (three.js v59dev)
 */

// MAIN

// standard global variables
var container, scene, renderer, controls, stats, player;
var keyboard = new THREEx.KeyboardState();
var clock = new THREE.Clock();

// custom global variables
var MovingCube;
var mainCamera;

// intermediate scene for reflecting the reflection
var screenScene, screenCamera, firstRenderTarget, finalRenderTarget, playerCylinder;

// sizing
var hex_cameras = [];
var hex_camera_targets = [];
var hex_planes = [];
var hex_render_targets = [];
var HEX_PANEL_HEIGHT = 9;
var HEX_PANEL_WIDTH = 6;

var HEX_NUM_PIXELS = 1024 * 1024;

init();
requestAnimationFrame(animate);

// FUNCTIONS
function init()
{
    // SCENE
    scene = new Physijs.Scene();
    scene.setGravity(new THREE.Vector3( 0, -30, 0 ));

    // CAMERAS
    var SCREEN_WIDTH = window.innerWidth, SCREEN_HEIGHT = window.innerHeight;
    var VIEW_ANGLE = 45, ASPECT = SCREEN_WIDTH / SCREEN_HEIGHT, NEAR = 0.1, FAR = 20000;
    // camera 1
    mainCamera = new THREE.PerspectiveCamera( VIEW_ANGLE, ASPECT, NEAR, FAR );
    scene.add(mainCamera);
    mainCamera.position.set(0,20,0);
//    mainCamera.lookAt(scene.position);

    // RENDERER


    if ( Detector.webgl )
        renderer = new THREE.WebGLRenderer( {antialias:true} );
    else
        renderer = new THREE.CanvasRenderer();
    renderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);
    container = document.getElementById( 'ThreeJS' );
    container.appendChild( renderer.domElement );

    // EVENTS
    THREEx.WindowResize(renderer, mainCamera);

    // controls
    controls = new THREE.OrbitControls( mainCamera, renderer.domElement );

    // STATS
    stats = new Stats();
    stats.domElement.style.position = 'absolute';
    stats.domElement.style.bottom = '0px';
    stats.domElement.style.zIndex = 100;
    container.appendChild( stats.domElement );

    // LIGHT
    var light = new THREE.PointLight(0xffffff);
    light.position.set(0,250,0);
    scene.add(light);

    // FLOOR
    var floorWidth = 100;
    var floorTexture = new THREE.ImageUtils.loadTexture( 'images/checkerboard.jpg' );
    floorTexture.wrapS = floorTexture.wrapT = THREE.RepeatWrapping;
    floorTexture.repeat.set( floorWidth/4, floorWidth/4 );
    var floorMaterial = new THREE.MeshBasicMaterial( { map: floorTexture, side: THREE.FrontSide } );
    var floorGeometry = new THREE.PlaneGeometry(floorWidth, floorWidth, 10, 10);
    var floor = new Physijs.BoxMesh(floorGeometry, floorMaterial, 0);
    floor.position.y = 0;
    floor.rotation.x = -Math.PI / 2;
    scene.add(floor);
    // SKYBOX/FOG
    var materialArray = [];
    materialArray.push(new THREE.MeshBasicMaterial( { map: THREE.ImageUtils.loadTexture( 'images/dawnmountain-xpos.png' ) }));
    materialArray.push(new THREE.MeshBasicMaterial( { map: THREE.ImageUtils.loadTexture( 'images/dawnmountain-xneg.png' ) }));
    materialArray.push(new THREE.MeshBasicMaterial( { map: THREE.ImageUtils.loadTexture( 'images/dawnmountain-ypos.png' ) }));
    materialArray.push(new THREE.MeshBasicMaterial( { map: THREE.ImageUtils.loadTexture( 'images/dawnmountain-yneg.png' ) }));
    materialArray.push(new THREE.MeshBasicMaterial( { map: THREE.ImageUtils.loadTexture( 'images/dawnmountain-zpos.png' ) }));
    materialArray.push(new THREE.MeshBasicMaterial( { map: THREE.ImageUtils.loadTexture( 'images/dawnmountain-zneg.png' ) }));
    for (var i = 0; i < 6; i++)
        materialArray[i].side = THREE.BackSide;
    var skyboxMaterial = new THREE.MeshFaceMaterial( materialArray );

    var skyboxGeom = new THREE.CubeGeometry( 5000, 5000, 5000, 1, 1, 1 );

    var skybox = new THREE.Mesh( skyboxGeom, skyboxMaterial );
    scene.add( skybox );

    ////////////
    // CUSTOM //
    ////////////

    // create an array with six textures for a cool cube
    var cubeMaterialArray = [];
    cubeMaterialArray.push(new THREE.MeshBasicMaterial( { map: THREE.ImageUtils.loadTexture( 'images/xpos.png' ) }));
    cubeMaterialArray.push(new THREE.MeshBasicMaterial( { map: THREE.ImageUtils.loadTexture( 'images/xneg.png' ) }));
    cubeMaterialArray.push(new THREE.MeshBasicMaterial( { map: THREE.ImageUtils.loadTexture( 'images/ypos.png' ) }));
    cubeMaterialArray.push(new THREE.MeshBasicMaterial( { map: THREE.ImageUtils.loadTexture( 'images/yneg.png' ) }));
    cubeMaterialArray.push(new THREE.MeshBasicMaterial( { map: THREE.ImageUtils.loadTexture( 'images/zpos.png' ) }));
    cubeMaterialArray.push(new THREE.MeshBasicMaterial( { map: THREE.ImageUtils.loadTexture( 'images/zneg.png' ) }));
    var MovingCubeMat = new THREE.MeshFaceMaterial(cubeMaterialArray);
    var MovingCubeGeom = new THREE.CubeGeometry( 5, 5, 5, 1, 1, 1, cubeMaterialArray );
    MovingCube = new Physijs.BoxMesh( MovingCubeGeom, MovingCubeMat );
    MovingCube.position.set(10, 5, 10);
    scene.add( MovingCube );

    // a little bit of scenery...
    var ambientlight = new THREE.AmbientLight(0x111111);
    scene.add( ambientlight );
    var wireMaterial = new THREE.MeshBasicMaterial( { color: 0x000000, wireframe: true, transparent: true } );
    // torus knot
    var colorMaterial = new THREE.MeshPhongMaterial( { color: 0xff3333 } );
    var shape = new Physijs.SphereMesh( new THREE.SphereGeometry(5, 5, 5), new THREE.MeshNormalMaterial() );
    shape.position.set(-20, 5, -20);
    scene.add( shape );
    // torus knot
    var colorMaterial = new THREE.MeshPhongMaterial( { color: 0x33ff33 } );
    var shape = new Physijs.ConvexMesh(new THREE.TorusKnotGeometry( 3, .6, 160, 10, 3, 2 ), colorMaterial );
    shape.position.set(20, 5, -20);
    scene.add( shape );
    // torus knot
    var colorMaterial = new THREE.MeshPhongMaterial( { color: 0xffff33 } );
    var shape = new Physijs.ConvexMesh(new THREE.TorusKnotGeometry( 3, .6, 160, 10, 4, 3 ), colorMaterial );
    shape.position.set(20, 5, 20);
    scene.add( shape );
    // torus knot
    var colorMaterial = new THREE.MeshPhongMaterial( { color: 0x3333ff } );
    var shape = new Physijs.ConvexMesh(new THREE.TorusKnotGeometry( 3, .6, 160, 10, 3, 4 ), colorMaterial );
    shape.position.set(-20, 5, 20);
    scene.add( shape );

    // render planes
    var hex_center_distance = HEX_PANEL_WIDTH / 2 * Math.sqrt(3);
    var hex_pixel_width = Math.round(Math.sqrt(HEX_NUM_PIXELS * (HEX_PANEL_WIDTH/HEX_PANEL_HEIGHT)));
    var hex_pixel_height = Math.round(HEX_NUM_PIXELS / hex_pixel_width);
    console.log(hex_pixel_width, hex_pixel_height, HEX_NUM_PIXELS);
    for (var j=0; j<6; j++) {
        hex_cameras[j] = new THREE.PerspectiveCamera( THREE.Math.radToDeg(Math.atan((HEX_PANEL_HEIGHT / 2) / hex_center_distance)) * 2, HEX_PANEL_WIDTH / HEX_PANEL_HEIGHT, NEAR, FAR );
        scene.add(hex_cameras[j]);

        hex_camera_targets[j] = new THREE.Vector3(0, 0, 0);

        var planeGeometry = new THREE.PlaneGeometry( HEX_PANEL_WIDTH, HEX_PANEL_HEIGHT );
        hex_render_targets[j] = new THREE.WebGLRenderTarget( hex_pixel_width, hex_pixel_height, { format: THREE.RGBFormat } );
        var planeMaterial = new THREE.MeshBasicMaterial( { map: hex_render_targets[j], side: THREE.DoubleSide } );
        hex_planes[j] = new THREE.Mesh( planeGeometry, planeMaterial, 10 );
        hex_planes[j].position.set(hex_center_distance * Math.cos(Math.PI * 2 / 6 * j), HEX_PANEL_HEIGHT/2, hex_center_distance * Math.sin(Math.PI * 2 / 6 * j));
        hex_planes[j].rotation.y = -(Math.PI * 2 / 6 * j + Math.PI / 2);

        scene.add(hex_planes[j]);
    }

    // pseudo-border for plane, to make it easier to see
//    var planeGeometry = new THREE.CubeGeometry( 420, 220, 1, 1 );
//    var planeMaterial = new THREE.MeshBasicMaterial( { color: 0x000000 } );
//    var plane = new THREE.Mesh( planeGeometry, planeMaterial );
//    plane.position.set(0,100,-502);
//    scene.add(plane);

    THREEx.MinecraftChar.baseUrl = "/threex.minecraft/";
    player = new THREEx.MinecraftPlayer();
//    player.character.root.scale.set(50, 50, 50);
    player.character.loadWellKnownSkin('3djesus');

    playerCylinder = new Physijs.CapsuleMesh(new THREE.CylinderGeometry(1.5, 1.5, 6), new THREE.MeshNormalMaterial());
    playerCylinder.add(player.character.root);
    playerCylinder.position.set(0, 10, 0);
    scene.add(playerCylinder);
    playerCylinder.setAngularFactor({x: 0, y: 0, z: 0});
    playerCylinder.setDamping(0, 0.8);

//    var loader = new THREE.JSONLoader();
//    loader.load( '/Island_001.js', function ( geometry, material ) {
//
//        var object = new Physijs.BoxMesh(geometry, new THREE.MeshNormalMaterial(), 0);
//        object.position.y = -500;
//        object.scale.set(10, 10, 10);
//        scene.add( object );
//
//    } );
}

var isSpacePressed = false;

function animate(nowMsec)
{
    requestAnimationFrame( animate );


    // hex

    playerCylinder.visible = false;
    for (var j=0; j<6; j++) {

        renderer.render( scene, hex_cameras[j], hex_render_targets[j], true );

        hex_cameras[j].position.copy(playerCylinder.position);

        hex_camera_targets[j].copy(playerCylinder.position);
        hex_camera_targets[j].x += Math.cos(Math.PI * 2 / 6 * j);
        hex_camera_targets[j].z += Math.sin(Math.PI * 2 / 6 * j);

        hex_cameras[j].lookAt( hex_camera_targets[j] );
    }
    playerCylinder.visible = true;


    // render the main scene
    renderer.render( scene, mainCamera );


    // Update Scene

    var delta = clock.getDelta(); // seconds.
    var moveDistance = 200 * delta * 10; // 200 pixels per second
    var rotateAngle = Math.PI / 2 * delta;   // pi/2 radians (90 degrees) per second

    // local transformations

    var input = player.controls.input;
    // move forwards/backwards/left/right
    var angle = (playerCylinder.rotation.x == 0) ? playerCylinder.rotation.y : Math.PI - playerCylinder.rotation.y;
    var velocity = new THREE.Vector3();
    var velocityX = Math.cos(playerCylinder.rotation.y);
    velocity.copy(playerCylinder.getLinearVelocity());
    if ( keyboard.pressed("W") ) {
        velocity.z = 10 * Math.cos(angle);
        velocity.x = 10 * Math.sin(angle);
    }
    if ( keyboard.pressed("S") ) {
        velocity.z = -10 * Math.cos(angle);
        velocity.x = -10 * Math.sin(angle);
    }
    if ( keyboard.pressed("E") ) {
        velocity.z = 10 * Math.cos(angle - Math.PI / 2);
        velocity.x = 10 * Math.sin(angle - Math.PI / 2);
    }
    if ( keyboard.pressed("Q") ) {
        velocity.z = -10 * Math.cos(angle - Math.PI / 2);
        velocity.x = -10 * Math.sin(angle - Math.PI / 2);
    }
    playerCylinder.setLinearVelocity(velocity);

    if (keyboard.pressed("space")) {
        if (!isSpacePressed) {
            console.log("jump");
            playerCylinder.applyCentralImpulse(new THREE.Vector3(0, 1000, 0));
        }
        isSpacePressed = true;
    } else {
        isSpacePressed = false;
    }

    input.up = keyboard.pressed("W");
    input.down = keyboard.pressed("S");
    input.left = keyboard.pressed("A");
    input.right = keyboard.pressed("D");
    input.strafeLeft = keyboard.pressed("Q");
    input.strafeRight = keyboard.pressed("E");

    // rotate left/right/up/down
    var angularVelocity = new THREE.Vector3();
    angularVelocity.copy(playerCylinder.getAngularVelocity());
    if ( keyboard.pressed("A") )
        angularVelocity.y = 2;
    if ( keyboard.pressed("D") )
        angularVelocity.y = -2;
    playerCylinder.setAngularVelocity(angularVelocity);

    if ( keyboard.pressed("Z") )
    {
        playerCylinder.position.set(0,25.1,0);
        playerCylinder.rotation.set(0,0,0);
        playerCylinder.__dirtyPosition = true;
        playerCylinder.__dirtyRotation = true;
    }

    player.update(delta, nowMsec/1000);

    controls.update();
    stats.update();

    scene.simulate();
}

</script>

</body>
</html>
